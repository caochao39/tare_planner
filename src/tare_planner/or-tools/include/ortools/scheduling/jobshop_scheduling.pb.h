// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/scheduling/jobshop_scheduling.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
namespace operations_research {
namespace scheduling {
namespace jssp {
class AssignedJob;
struct AssignedJobDefaultTypeInternal;
extern AssignedJobDefaultTypeInternal _AssignedJob_default_instance_;
class AssignedTask;
struct AssignedTaskDefaultTypeInternal;
extern AssignedTaskDefaultTypeInternal _AssignedTask_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class JobPrecedence;
struct JobPrecedenceDefaultTypeInternal;
extern JobPrecedenceDefaultTypeInternal _JobPrecedence_default_instance_;
class JsspInputProblem;
struct JsspInputProblemDefaultTypeInternal;
extern JsspInputProblemDefaultTypeInternal _JsspInputProblem_default_instance_;
class JsspOutputSolution;
struct JsspOutputSolutionDefaultTypeInternal;
extern JsspOutputSolutionDefaultTypeInternal _JsspOutputSolution_default_instance_;
class Machine;
struct MachineDefaultTypeInternal;
extern MachineDefaultTypeInternal _Machine_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TransitionTimeMatrix;
struct TransitionTimeMatrixDefaultTypeInternal;
extern TransitionTimeMatrixDefaultTypeInternal _TransitionTimeMatrix_default_instance_;
}  // namespace jssp
}  // namespace scheduling
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> ::operations_research::scheduling::jssp::AssignedJob* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::AssignedJob>(Arena*);
template<> ::operations_research::scheduling::jssp::AssignedTask* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::AssignedTask>(Arena*);
template<> ::operations_research::scheduling::jssp::Job* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::Job>(Arena*);
template<> ::operations_research::scheduling::jssp::JobPrecedence* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::JobPrecedence>(Arena*);
template<> ::operations_research::scheduling::jssp::JsspInputProblem* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::JsspInputProblem>(Arena*);
template<> ::operations_research::scheduling::jssp::JsspOutputSolution* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::JsspOutputSolution>(Arena*);
template<> ::operations_research::scheduling::jssp::Machine* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::Machine>(Arena*);
template<> ::operations_research::scheduling::jssp::Task* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::Task>(Arena*);
template<> ::operations_research::scheduling::jssp::TransitionTimeMatrix* Arena::CreateMaybeMessage<::operations_research::scheduling::jssp::TransitionTimeMatrix>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace operations_research {
namespace scheduling {
namespace jssp {

// ===================================================================

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineFieldNumber = 1,
    kDurationFieldNumber = 2,
    kCostFieldNumber = 3,
  };
  // repeated int32 machine = 1;
  int machine_size() const;
  private:
  int _internal_machine_size() const;
  public:
  void clear_machine();
  private:
  int32_t _internal_machine(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_machine() const;
  void _internal_add_machine(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_machine();
  public:
  int32_t machine(int index) const;
  void set_machine(int index, int32_t value);
  void add_machine(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      machine() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_machine();

  // repeated int64 duration = 2;
  int duration_size() const;
  private:
  int _internal_duration_size() const;
  public:
  void clear_duration();
  private:
  int64_t _internal_duration(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_duration() const;
  void _internal_add_duration(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_duration();
  public:
  int64_t duration(int index) const;
  void set_duration(int index, int64_t value);
  void add_duration(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      duration() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_duration();

  // repeated int64 cost = 3;
  int cost_size() const;
  private:
  int _internal_cost_size() const;
  public:
  void clear_cost();
  private:
  int64_t _internal_cost(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_cost() const;
  void _internal_add_cost(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_cost();
  public:
  int64_t cost(int index) const;
  void set_cost(int index, int64_t value);
  void add_cost(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      cost() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_cost();

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > machine_;
    mutable std::atomic<int> _machine_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > duration_;
    mutable std::atomic<int> _duration_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > cost_;
    mutable std::atomic<int> _cost_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class Job final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  explicit PROTOBUF_CONSTEXPR Job(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.Job";
  }
  protected:
  explicit Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
    kNameFieldNumber = 16,
    kEarliestStartFieldNumber = 2,
    kLatestEndFieldNumber = 7,
    kEarlyDueDateFieldNumber = 3,
    kLateDueDateFieldNumber = 4,
    kEarlinessCostPerTimeUnitFieldNumber = 5,
    kLatenessCostPerTimeUnitFieldNumber = 6,
  };
  // repeated .operations_research.scheduling.jssp.Task tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::operations_research::scheduling::jssp::Task* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >*
      mutable_tasks();
  private:
  const ::operations_research::scheduling::jssp::Task& _internal_tasks(int index) const;
  ::operations_research::scheduling::jssp::Task* _internal_add_tasks();
  public:
  const ::operations_research::scheduling::jssp::Task& tasks(int index) const;
  ::operations_research::scheduling::jssp::Task* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >&
      tasks() const;

  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Int64Value earliest_start = 2;
  bool has_earliest_start() const;
  private:
  bool _internal_has_earliest_start() const;
  public:
  void clear_earliest_start();
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& earliest_start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int64Value* release_earliest_start();
  ::PROTOBUF_NAMESPACE_ID::Int64Value* mutable_earliest_start();
  void set_allocated_earliest_start(::PROTOBUF_NAMESPACE_ID::Int64Value* earliest_start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& _internal_earliest_start() const;
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_earliest_start();
  public:
  void unsafe_arena_set_allocated_earliest_start(
      ::PROTOBUF_NAMESPACE_ID::Int64Value* earliest_start);
  ::PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_earliest_start();

  // .google.protobuf.Int64Value latest_end = 7;
  bool has_latest_end() const;
  private:
  bool _internal_has_latest_end() const;
  public:
  void clear_latest_end();
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& latest_end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int64Value* release_latest_end();
  ::PROTOBUF_NAMESPACE_ID::Int64Value* mutable_latest_end();
  void set_allocated_latest_end(::PROTOBUF_NAMESPACE_ID::Int64Value* latest_end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& _internal_latest_end() const;
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_latest_end();
  public:
  void unsafe_arena_set_allocated_latest_end(
      ::PROTOBUF_NAMESPACE_ID::Int64Value* latest_end);
  ::PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_latest_end();

  // int64 early_due_date = 3;
  void clear_early_due_date();
  int64_t early_due_date() const;
  void set_early_due_date(int64_t value);
  private:
  int64_t _internal_early_due_date() const;
  void _internal_set_early_due_date(int64_t value);
  public:

  // int64 late_due_date = 4;
  void clear_late_due_date();
  int64_t late_due_date() const;
  void set_late_due_date(int64_t value);
  private:
  int64_t _internal_late_due_date() const;
  void _internal_set_late_due_date(int64_t value);
  public:

  // int64 earliness_cost_per_time_unit = 5;
  void clear_earliness_cost_per_time_unit();
  int64_t earliness_cost_per_time_unit() const;
  void set_earliness_cost_per_time_unit(int64_t value);
  private:
  int64_t _internal_earliness_cost_per_time_unit() const;
  void _internal_set_earliness_cost_per_time_unit(int64_t value);
  public:

  // int64 lateness_cost_per_time_unit = 6;
  void clear_lateness_cost_per_time_unit();
  int64_t lateness_cost_per_time_unit() const;
  void set_lateness_cost_per_time_unit(int64_t value);
  private:
  int64_t _internal_lateness_cost_per_time_unit() const;
  void _internal_set_lateness_cost_per_time_unit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Job)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Task > tasks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Int64Value* earliest_start_;
    ::PROTOBUF_NAMESPACE_ID::Int64Value* latest_end_;
    int64_t early_due_date_;
    int64_t late_due_date_;
    int64_t earliness_cost_per_time_unit_;
    int64_t lateness_cost_per_time_unit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class TransitionTimeMatrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.TransitionTimeMatrix) */ {
 public:
  inline TransitionTimeMatrix() : TransitionTimeMatrix(nullptr) {}
  ~TransitionTimeMatrix() override;
  explicit PROTOBUF_CONSTEXPR TransitionTimeMatrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransitionTimeMatrix(const TransitionTimeMatrix& from);
  TransitionTimeMatrix(TransitionTimeMatrix&& from) noexcept
    : TransitionTimeMatrix() {
    *this = ::std::move(from);
  }

  inline TransitionTimeMatrix& operator=(const TransitionTimeMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitionTimeMatrix& operator=(TransitionTimeMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitionTimeMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitionTimeMatrix* internal_default_instance() {
    return reinterpret_cast<const TransitionTimeMatrix*>(
               &_TransitionTimeMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TransitionTimeMatrix& a, TransitionTimeMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitionTimeMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitionTimeMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitionTimeMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitionTimeMatrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransitionTimeMatrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransitionTimeMatrix& from) {
    TransitionTimeMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitionTimeMatrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.TransitionTimeMatrix";
  }
  protected:
  explicit TransitionTimeMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitionTimeFieldNumber = 1,
  };
  // repeated int64 transition_time = 1;
  int transition_time_size() const;
  private:
  int _internal_transition_time_size() const;
  public:
  void clear_transition_time();
  private:
  int64_t _internal_transition_time(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_transition_time() const;
  void _internal_add_transition_time(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_transition_time();
  public:
  int64_t transition_time(int index) const;
  void set_transition_time(int index, int64_t value);
  void add_transition_time(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      transition_time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_transition_time();

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.TransitionTimeMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > transition_time_;
    mutable std::atomic<int> _transition_time_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class Machine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Machine) */ {
 public:
  inline Machine() : Machine(nullptr) {}
  ~Machine() override;
  explicit PROTOBUF_CONSTEXPR Machine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Machine(const Machine& from);
  Machine(Machine&& from) noexcept
    : Machine() {
    *this = ::std::move(from);
  }

  inline Machine& operator=(const Machine& from) {
    CopyFrom(from);
    return *this;
  }
  inline Machine& operator=(Machine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Machine& default_instance() {
    return *internal_default_instance();
  }
  static inline const Machine* internal_default_instance() {
    return reinterpret_cast<const Machine*>(
               &_Machine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Machine& a, Machine& b) {
    a.Swap(&b);
  }
  inline void Swap(Machine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Machine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Machine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Machine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Machine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Machine& from) {
    Machine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.Machine";
  }
  protected:
  explicit Machine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 16,
    kTransitionTimeMatrixFieldNumber = 1,
  };
  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .operations_research.scheduling.jssp.TransitionTimeMatrix transition_time_matrix = 1;
  bool has_transition_time_matrix() const;
  private:
  bool _internal_has_transition_time_matrix() const;
  public:
  void clear_transition_time_matrix();
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix& transition_time_matrix() const;
  PROTOBUF_NODISCARD ::operations_research::scheduling::jssp::TransitionTimeMatrix* release_transition_time_matrix();
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* mutable_transition_time_matrix();
  void set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix);
  private:
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix& _internal_transition_time_matrix() const;
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* _internal_mutable_transition_time_matrix();
  public:
  void unsafe_arena_set_allocated_transition_time_matrix(
      ::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix);
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* unsafe_arena_release_transition_time_matrix();

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Machine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class JobPrecedence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JobPrecedence) */ {
 public:
  inline JobPrecedence() : JobPrecedence(nullptr) {}
  ~JobPrecedence() override;
  explicit PROTOBUF_CONSTEXPR JobPrecedence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobPrecedence(const JobPrecedence& from);
  JobPrecedence(JobPrecedence&& from) noexcept
    : JobPrecedence() {
    *this = ::std::move(from);
  }

  inline JobPrecedence& operator=(const JobPrecedence& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobPrecedence& operator=(JobPrecedence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobPrecedence& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobPrecedence* internal_default_instance() {
    return reinterpret_cast<const JobPrecedence*>(
               &_JobPrecedence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JobPrecedence& a, JobPrecedence& b) {
    a.Swap(&b);
  }
  inline void Swap(JobPrecedence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobPrecedence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobPrecedence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobPrecedence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobPrecedence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobPrecedence& from) {
    JobPrecedence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobPrecedence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.JobPrecedence";
  }
  protected:
  explicit JobPrecedence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstJobIndexFieldNumber = 1,
    kSecondJobIndexFieldNumber = 2,
    kMinDelayFieldNumber = 3,
  };
  // int32 first_job_index = 1;
  void clear_first_job_index();
  int32_t first_job_index() const;
  void set_first_job_index(int32_t value);
  private:
  int32_t _internal_first_job_index() const;
  void _internal_set_first_job_index(int32_t value);
  public:

  // int32 second_job_index = 2;
  void clear_second_job_index();
  int32_t second_job_index() const;
  void set_second_job_index(int32_t value);
  private:
  int32_t _internal_second_job_index() const;
  void _internal_set_second_job_index(int32_t value);
  public:

  // int64 min_delay = 3;
  void clear_min_delay();
  int64_t min_delay() const;
  void set_min_delay(int64_t value);
  private:
  int64_t _internal_min_delay() const;
  void _internal_set_min_delay(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JobPrecedence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t first_job_index_;
    int32_t second_job_index_;
    int64_t min_delay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class JsspInputProblem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JsspInputProblem) */ {
 public:
  inline JsspInputProblem() : JsspInputProblem(nullptr) {}
  ~JsspInputProblem() override;
  explicit PROTOBUF_CONSTEXPR JsspInputProblem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsspInputProblem(const JsspInputProblem& from);
  JsspInputProblem(JsspInputProblem&& from) noexcept
    : JsspInputProblem() {
    *this = ::std::move(from);
  }

  inline JsspInputProblem& operator=(const JsspInputProblem& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsspInputProblem& operator=(JsspInputProblem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JsspInputProblem& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsspInputProblem* internal_default_instance() {
    return reinterpret_cast<const JsspInputProblem*>(
               &_JsspInputProblem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JsspInputProblem& a, JsspInputProblem& b) {
    a.Swap(&b);
  }
  inline void Swap(JsspInputProblem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsspInputProblem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsspInputProblem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsspInputProblem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JsspInputProblem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JsspInputProblem& from) {
    JsspInputProblem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JsspInputProblem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.JsspInputProblem";
  }
  protected:
  explicit JsspInputProblem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kMachinesFieldNumber = 2,
    kPrecedencesFieldNumber = 3,
    kNameFieldNumber = 16,
    kScalingFactorFieldNumber = 5,
    kMakespanCostPerTimeUnitFieldNumber = 4,
    kSeedFieldNumber = 24,
  };
  // repeated .operations_research.scheduling.jssp.Job jobs = 1;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;
  public:
  void clear_jobs();
  ::operations_research::scheduling::jssp::Job* mutable_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >*
      mutable_jobs();
  private:
  const ::operations_research::scheduling::jssp::Job& _internal_jobs(int index) const;
  ::operations_research::scheduling::jssp::Job* _internal_add_jobs();
  public:
  const ::operations_research::scheduling::jssp::Job& jobs(int index) const;
  ::operations_research::scheduling::jssp::Job* add_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >&
      jobs() const;

  // repeated .operations_research.scheduling.jssp.Machine machines = 2;
  int machines_size() const;
  private:
  int _internal_machines_size() const;
  public:
  void clear_machines();
  ::operations_research::scheduling::jssp::Machine* mutable_machines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >*
      mutable_machines();
  private:
  const ::operations_research::scheduling::jssp::Machine& _internal_machines(int index) const;
  ::operations_research::scheduling::jssp::Machine* _internal_add_machines();
  public:
  const ::operations_research::scheduling::jssp::Machine& machines(int index) const;
  ::operations_research::scheduling::jssp::Machine* add_machines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >&
      machines() const;

  // repeated .operations_research.scheduling.jssp.JobPrecedence precedences = 3;
  int precedences_size() const;
  private:
  int _internal_precedences_size() const;
  public:
  void clear_precedences();
  ::operations_research::scheduling::jssp::JobPrecedence* mutable_precedences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >*
      mutable_precedences();
  private:
  const ::operations_research::scheduling::jssp::JobPrecedence& _internal_precedences(int index) const;
  ::operations_research::scheduling::jssp::JobPrecedence* _internal_add_precedences();
  public:
  const ::operations_research::scheduling::jssp::JobPrecedence& precedences(int index) const;
  ::operations_research::scheduling::jssp::JobPrecedence* add_precedences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >&
      precedences() const;

  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.DoubleValue scaling_factor = 5;
  bool has_scaling_factor() const;
  private:
  bool _internal_has_scaling_factor() const;
  public:
  void clear_scaling_factor();
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& scaling_factor() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_scaling_factor();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_scaling_factor();
  void set_allocated_scaling_factor(::PROTOBUF_NAMESPACE_ID::DoubleValue* scaling_factor);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_scaling_factor() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_scaling_factor();
  public:
  void unsafe_arena_set_allocated_scaling_factor(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* scaling_factor);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_scaling_factor();

  // int64 makespan_cost_per_time_unit = 4;
  void clear_makespan_cost_per_time_unit();
  int64_t makespan_cost_per_time_unit() const;
  void set_makespan_cost_per_time_unit(int64_t value);
  private:
  int64_t _internal_makespan_cost_per_time_unit() const;
  void _internal_set_makespan_cost_per_time_unit(int64_t value);
  public:

  // int32 seed = 24;
  void clear_seed();
  int32_t seed() const;
  void set_seed(int32_t value);
  private:
  int32_t _internal_seed() const;
  void _internal_set_seed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JsspInputProblem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Job > jobs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine > machines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence > precedences_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* scaling_factor_;
    int64_t makespan_cost_per_time_unit_;
    int32_t seed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class AssignedTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.AssignedTask) */ {
 public:
  inline AssignedTask() : AssignedTask(nullptr) {}
  ~AssignedTask() override;
  explicit PROTOBUF_CONSTEXPR AssignedTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignedTask(const AssignedTask& from);
  AssignedTask(AssignedTask&& from) noexcept
    : AssignedTask() {
    *this = ::std::move(from);
  }

  inline AssignedTask& operator=(const AssignedTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignedTask& operator=(AssignedTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignedTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignedTask* internal_default_instance() {
    return reinterpret_cast<const AssignedTask*>(
               &_AssignedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AssignedTask& a, AssignedTask& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignedTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignedTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignedTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignedTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignedTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssignedTask& from) {
    AssignedTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignedTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.AssignedTask";
  }
  protected:
  explicit AssignedTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 2,
    kAlternativeIndexFieldNumber = 1,
  };
  // int64 start_time = 2;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int32 alternative_index = 1;
  void clear_alternative_index();
  int32_t alternative_index() const;
  void set_alternative_index(int32_t value);
  private:
  int32_t _internal_alternative_index() const;
  void _internal_set_alternative_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.AssignedTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t start_time_;
    int32_t alternative_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class AssignedJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.AssignedJob) */ {
 public:
  inline AssignedJob() : AssignedJob(nullptr) {}
  ~AssignedJob() override;
  explicit PROTOBUF_CONSTEXPR AssignedJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignedJob(const AssignedJob& from);
  AssignedJob(AssignedJob&& from) noexcept
    : AssignedJob() {
    *this = ::std::move(from);
  }

  inline AssignedJob& operator=(const AssignedJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignedJob& operator=(AssignedJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignedJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignedJob* internal_default_instance() {
    return reinterpret_cast<const AssignedJob*>(
               &_AssignedJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AssignedJob& a, AssignedJob& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignedJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignedJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignedJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignedJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignedJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssignedJob& from) {
    AssignedJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignedJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.AssignedJob";
  }
  protected:
  explicit AssignedJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
    kDueDateCostFieldNumber = 2,
    kSumOfTaskCostsFieldNumber = 3,
  };
  // repeated .operations_research.scheduling.jssp.AssignedTask tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::operations_research::scheduling::jssp::AssignedTask* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >*
      mutable_tasks();
  private:
  const ::operations_research::scheduling::jssp::AssignedTask& _internal_tasks(int index) const;
  ::operations_research::scheduling::jssp::AssignedTask* _internal_add_tasks();
  public:
  const ::operations_research::scheduling::jssp::AssignedTask& tasks(int index) const;
  ::operations_research::scheduling::jssp::AssignedTask* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >&
      tasks() const;

  // int64 due_date_cost = 2;
  void clear_due_date_cost();
  int64_t due_date_cost() const;
  void set_due_date_cost(int64_t value);
  private:
  int64_t _internal_due_date_cost() const;
  void _internal_set_due_date_cost(int64_t value);
  public:

  // int64 sum_of_task_costs = 3;
  void clear_sum_of_task_costs();
  int64_t sum_of_task_costs() const;
  void set_sum_of_task_costs(int64_t value);
  private:
  int64_t _internal_sum_of_task_costs() const;
  void _internal_set_sum_of_task_costs(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.AssignedJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask > tasks_;
    int64_t due_date_cost_;
    int64_t sum_of_task_costs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// -------------------------------------------------------------------

class JsspOutputSolution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JsspOutputSolution) */ {
 public:
  inline JsspOutputSolution() : JsspOutputSolution(nullptr) {}
  ~JsspOutputSolution() override;
  explicit PROTOBUF_CONSTEXPR JsspOutputSolution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsspOutputSolution(const JsspOutputSolution& from);
  JsspOutputSolution(JsspOutputSolution&& from) noexcept
    : JsspOutputSolution() {
    *this = ::std::move(from);
  }

  inline JsspOutputSolution& operator=(const JsspOutputSolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsspOutputSolution& operator=(JsspOutputSolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JsspOutputSolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsspOutputSolution* internal_default_instance() {
    return reinterpret_cast<const JsspOutputSolution*>(
               &_JsspOutputSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JsspOutputSolution& a, JsspOutputSolution& b) {
    a.Swap(&b);
  }
  inline void Swap(JsspOutputSolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsspOutputSolution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsspOutputSolution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsspOutputSolution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JsspOutputSolution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JsspOutputSolution& from) {
    JsspOutputSolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JsspOutputSolution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.scheduling.jssp.JsspOutputSolution";
  }
  protected:
  explicit JsspOutputSolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kMakespanCostFieldNumber = 2,
    kTotalCostFieldNumber = 3,
  };
  // repeated .operations_research.scheduling.jssp.AssignedJob jobs = 1;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;
  public:
  void clear_jobs();
  ::operations_research::scheduling::jssp::AssignedJob* mutable_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >*
      mutable_jobs();
  private:
  const ::operations_research::scheduling::jssp::AssignedJob& _internal_jobs(int index) const;
  ::operations_research::scheduling::jssp::AssignedJob* _internal_add_jobs();
  public:
  const ::operations_research::scheduling::jssp::AssignedJob& jobs(int index) const;
  ::operations_research::scheduling::jssp::AssignedJob* add_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >&
      jobs() const;

  // int64 makespan_cost = 2;
  void clear_makespan_cost();
  int64_t makespan_cost() const;
  void set_makespan_cost(int64_t value);
  private:
  int64_t _internal_makespan_cost() const;
  void _internal_set_makespan_cost(int64_t value);
  public:

  // int64 total_cost = 3;
  void clear_total_cost();
  int64_t total_cost() const;
  void set_total_cost(int64_t value);
  private:
  int64_t _internal_total_cost() const;
  void _internal_set_total_cost(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JsspOutputSolution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob > jobs_;
    int64_t makespan_cost_;
    int64_t total_cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Task

// repeated int32 machine = 1;
inline int Task::_internal_machine_size() const {
  return _impl_.machine_.size();
}
inline int Task::machine_size() const {
  return _internal_machine_size();
}
inline void Task::clear_machine() {
  _impl_.machine_.Clear();
}
inline int32_t Task::_internal_machine(int index) const {
  return _impl_.machine_.Get(index);
}
inline int32_t Task::machine(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.machine)
  return _internal_machine(index);
}
inline void Task::set_machine(int index, int32_t value) {
  _impl_.machine_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.machine)
}
inline void Task::_internal_add_machine(int32_t value) {
  _impl_.machine_.Add(value);
}
inline void Task::add_machine(int32_t value) {
  _internal_add_machine(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.machine)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Task::_internal_machine() const {
  return _impl_.machine_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Task::machine() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.machine)
  return _internal_machine();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Task::_internal_mutable_machine() {
  return &_impl_.machine_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Task::mutable_machine() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.machine)
  return _internal_mutable_machine();
}

// repeated int64 duration = 2;
inline int Task::_internal_duration_size() const {
  return _impl_.duration_.size();
}
inline int Task::duration_size() const {
  return _internal_duration_size();
}
inline void Task::clear_duration() {
  _impl_.duration_.Clear();
}
inline int64_t Task::_internal_duration(int index) const {
  return _impl_.duration_.Get(index);
}
inline int64_t Task::duration(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.duration)
  return _internal_duration(index);
}
inline void Task::set_duration(int index, int64_t value) {
  _impl_.duration_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.duration)
}
inline void Task::_internal_add_duration(int64_t value) {
  _impl_.duration_.Add(value);
}
inline void Task::add_duration(int64_t value) {
  _internal_add_duration(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.duration)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Task::_internal_duration() const {
  return _impl_.duration_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Task::duration() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.duration)
  return _internal_duration();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Task::_internal_mutable_duration() {
  return &_impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Task::mutable_duration() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.duration)
  return _internal_mutable_duration();
}

// repeated int64 cost = 3;
inline int Task::_internal_cost_size() const {
  return _impl_.cost_.size();
}
inline int Task::cost_size() const {
  return _internal_cost_size();
}
inline void Task::clear_cost() {
  _impl_.cost_.Clear();
}
inline int64_t Task::_internal_cost(int index) const {
  return _impl_.cost_.Get(index);
}
inline int64_t Task::cost(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.cost)
  return _internal_cost(index);
}
inline void Task::set_cost(int index, int64_t value) {
  _impl_.cost_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.cost)
}
inline void Task::_internal_add_cost(int64_t value) {
  _impl_.cost_.Add(value);
}
inline void Task::add_cost(int64_t value) {
  _internal_add_cost(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.cost)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Task::_internal_cost() const {
  return _impl_.cost_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Task::cost() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.cost)
  return _internal_cost();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Task::_internal_mutable_cost() {
  return &_impl_.cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Task::mutable_cost() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.cost)
  return _internal_mutable_cost();
}

// -------------------------------------------------------------------

// Job

// repeated .operations_research.scheduling.jssp.Task tasks = 1;
inline int Job::_internal_tasks_size() const {
  return _impl_.tasks_.size();
}
inline int Job::tasks_size() const {
  return _internal_tasks_size();
}
inline void Job::clear_tasks() {
  _impl_.tasks_.Clear();
}
inline ::operations_research::scheduling::jssp::Task* Job::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.tasks)
  return _impl_.tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >*
Job::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Job.tasks)
  return &_impl_.tasks_;
}
inline const ::operations_research::scheduling::jssp::Task& Job::_internal_tasks(int index) const {
  return _impl_.tasks_.Get(index);
}
inline const ::operations_research::scheduling::jssp::Task& Job::tasks(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.tasks)
  return _internal_tasks(index);
}
inline ::operations_research::scheduling::jssp::Task* Job::_internal_add_tasks() {
  return _impl_.tasks_.Add();
}
inline ::operations_research::scheduling::jssp::Task* Job::add_tasks() {
  ::operations_research::scheduling::jssp::Task* _add = _internal_add_tasks();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Job.tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >&
Job::tasks() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Job.tasks)
  return _impl_.tasks_;
}

// .google.protobuf.Int64Value earliest_start = 2;
inline bool Job::_internal_has_earliest_start() const {
  return this != internal_default_instance() && _impl_.earliest_start_ != nullptr;
}
inline bool Job::has_earliest_start() const {
  return _internal_has_earliest_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& Job::_internal_earliest_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Int64Value* p = _impl_.earliest_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& Job::earliest_start() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.earliest_start)
  return _internal_earliest_start();
}
inline void Job::unsafe_arena_set_allocated_earliest_start(
    ::PROTOBUF_NAMESPACE_ID::Int64Value* earliest_start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.earliest_start_);
  }
  _impl_.earliest_start_ = earliest_start;
  if (earliest_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Job.earliest_start)
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::release_earliest_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.earliest_start_;
  _impl_.earliest_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::unsafe_arena_release_earliest_start() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.earliest_start)
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.earliest_start_;
  _impl_.earliest_start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::_internal_mutable_earliest_start() {
  
  if (_impl_.earliest_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int64Value>(GetArenaForAllocation());
    _impl_.earliest_start_ = p;
  }
  return _impl_.earliest_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::mutable_earliest_start() {
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _msg = _internal_mutable_earliest_start();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.earliest_start)
  return _msg;
}
inline void Job::set_allocated_earliest_start(::PROTOBUF_NAMESPACE_ID::Int64Value* earliest_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.earliest_start_);
  }
  if (earliest_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(earliest_start));
    if (message_arena != submessage_arena) {
      earliest_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, earliest_start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.earliest_start_ = earliest_start;
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.earliest_start)
}

// int64 early_due_date = 3;
inline void Job::clear_early_due_date() {
  _impl_.early_due_date_ = int64_t{0};
}
inline int64_t Job::_internal_early_due_date() const {
  return _impl_.early_due_date_;
}
inline int64_t Job::early_due_date() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.early_due_date)
  return _internal_early_due_date();
}
inline void Job::_internal_set_early_due_date(int64_t value) {
  
  _impl_.early_due_date_ = value;
}
inline void Job::set_early_due_date(int64_t value) {
  _internal_set_early_due_date(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.early_due_date)
}

// int64 late_due_date = 4;
inline void Job::clear_late_due_date() {
  _impl_.late_due_date_ = int64_t{0};
}
inline int64_t Job::_internal_late_due_date() const {
  return _impl_.late_due_date_;
}
inline int64_t Job::late_due_date() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.late_due_date)
  return _internal_late_due_date();
}
inline void Job::_internal_set_late_due_date(int64_t value) {
  
  _impl_.late_due_date_ = value;
}
inline void Job::set_late_due_date(int64_t value) {
  _internal_set_late_due_date(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.late_due_date)
}

// int64 earliness_cost_per_time_unit = 5;
inline void Job::clear_earliness_cost_per_time_unit() {
  _impl_.earliness_cost_per_time_unit_ = int64_t{0};
}
inline int64_t Job::_internal_earliness_cost_per_time_unit() const {
  return _impl_.earliness_cost_per_time_unit_;
}
inline int64_t Job::earliness_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.earliness_cost_per_time_unit)
  return _internal_earliness_cost_per_time_unit();
}
inline void Job::_internal_set_earliness_cost_per_time_unit(int64_t value) {
  
  _impl_.earliness_cost_per_time_unit_ = value;
}
inline void Job::set_earliness_cost_per_time_unit(int64_t value) {
  _internal_set_earliness_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.earliness_cost_per_time_unit)
}

// int64 lateness_cost_per_time_unit = 6;
inline void Job::clear_lateness_cost_per_time_unit() {
  _impl_.lateness_cost_per_time_unit_ = int64_t{0};
}
inline int64_t Job::_internal_lateness_cost_per_time_unit() const {
  return _impl_.lateness_cost_per_time_unit_;
}
inline int64_t Job::lateness_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.lateness_cost_per_time_unit)
  return _internal_lateness_cost_per_time_unit();
}
inline void Job::_internal_set_lateness_cost_per_time_unit(int64_t value) {
  
  _impl_.lateness_cost_per_time_unit_ = value;
}
inline void Job::set_lateness_cost_per_time_unit(int64_t value) {
  _internal_set_lateness_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.lateness_cost_per_time_unit)
}

// .google.protobuf.Int64Value latest_end = 7;
inline bool Job::_internal_has_latest_end() const {
  return this != internal_default_instance() && _impl_.latest_end_ != nullptr;
}
inline bool Job::has_latest_end() const {
  return _internal_has_latest_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& Job::_internal_latest_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Int64Value* p = _impl_.latest_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& Job::latest_end() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.latest_end)
  return _internal_latest_end();
}
inline void Job::unsafe_arena_set_allocated_latest_end(
    ::PROTOBUF_NAMESPACE_ID::Int64Value* latest_end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_end_);
  }
  _impl_.latest_end_ = latest_end;
  if (latest_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Job.latest_end)
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::release_latest_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.latest_end_;
  _impl_.latest_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::unsafe_arena_release_latest_end() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.latest_end)
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.latest_end_;
  _impl_.latest_end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::_internal_mutable_latest_end() {
  
  if (_impl_.latest_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int64Value>(GetArenaForAllocation());
    _impl_.latest_end_ = p;
  }
  return _impl_.latest_end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* Job::mutable_latest_end() {
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _msg = _internal_mutable_latest_end();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.latest_end)
  return _msg;
}
inline void Job::set_allocated_latest_end(::PROTOBUF_NAMESPACE_ID::Int64Value* latest_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_end_);
  }
  if (latest_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_end));
    if (message_arena != submessage_arena) {
      latest_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_end, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latest_end_ = latest_end;
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.latest_end)
}

// string name = 16;
inline void Job::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Job::name() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.name)
}
inline std::string* Job::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.name)
  return _s;
}
inline const std::string& Job::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Job::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.name)
  return _impl_.name_.Release();
}
inline void Job::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.name)
}

// -------------------------------------------------------------------

// TransitionTimeMatrix

// repeated int64 transition_time = 1;
inline int TransitionTimeMatrix::_internal_transition_time_size() const {
  return _impl_.transition_time_.size();
}
inline int TransitionTimeMatrix::transition_time_size() const {
  return _internal_transition_time_size();
}
inline void TransitionTimeMatrix::clear_transition_time() {
  _impl_.transition_time_.Clear();
}
inline int64_t TransitionTimeMatrix::_internal_transition_time(int index) const {
  return _impl_.transition_time_.Get(index);
}
inline int64_t TransitionTimeMatrix::transition_time(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  return _internal_transition_time(index);
}
inline void TransitionTimeMatrix::set_transition_time(int index, int64_t value) {
  _impl_.transition_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
}
inline void TransitionTimeMatrix::_internal_add_transition_time(int64_t value) {
  _impl_.transition_time_.Add(value);
}
inline void TransitionTimeMatrix::add_transition_time(int64_t value) {
  _internal_add_transition_time(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TransitionTimeMatrix::_internal_transition_time() const {
  return _impl_.transition_time_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TransitionTimeMatrix::transition_time() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  return _internal_transition_time();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TransitionTimeMatrix::_internal_mutable_transition_time() {
  return &_impl_.transition_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TransitionTimeMatrix::mutable_transition_time() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  return _internal_mutable_transition_time();
}

// -------------------------------------------------------------------

// Machine

// .operations_research.scheduling.jssp.TransitionTimeMatrix transition_time_matrix = 1;
inline bool Machine::_internal_has_transition_time_matrix() const {
  return this != internal_default_instance() && _impl_.transition_time_matrix_ != nullptr;
}
inline bool Machine::has_transition_time_matrix() const {
  return _internal_has_transition_time_matrix();
}
inline void Machine::clear_transition_time_matrix() {
  if (GetArenaForAllocation() == nullptr && _impl_.transition_time_matrix_ != nullptr) {
    delete _impl_.transition_time_matrix_;
  }
  _impl_.transition_time_matrix_ = nullptr;
}
inline const ::operations_research::scheduling::jssp::TransitionTimeMatrix& Machine::_internal_transition_time_matrix() const {
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix* p = _impl_.transition_time_matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::scheduling::jssp::TransitionTimeMatrix&>(
      ::operations_research::scheduling::jssp::_TransitionTimeMatrix_default_instance_);
}
inline const ::operations_research::scheduling::jssp::TransitionTimeMatrix& Machine::transition_time_matrix() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Machine.transition_time_matrix)
  return _internal_transition_time_matrix();
}
inline void Machine::unsafe_arena_set_allocated_transition_time_matrix(
    ::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transition_time_matrix_);
  }
  _impl_.transition_time_matrix_ = transition_time_matrix;
  if (transition_time_matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Machine.transition_time_matrix)
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::release_transition_time_matrix() {
  
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* temp = _impl_.transition_time_matrix_;
  _impl_.transition_time_matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::unsafe_arena_release_transition_time_matrix() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Machine.transition_time_matrix)
  
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* temp = _impl_.transition_time_matrix_;
  _impl_.transition_time_matrix_ = nullptr;
  return temp;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::_internal_mutable_transition_time_matrix() {
  
  if (_impl_.transition_time_matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::scheduling::jssp::TransitionTimeMatrix>(GetArenaForAllocation());
    _impl_.transition_time_matrix_ = p;
  }
  return _impl_.transition_time_matrix_;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::mutable_transition_time_matrix() {
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* _msg = _internal_mutable_transition_time_matrix();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Machine.transition_time_matrix)
  return _msg;
}
inline void Machine::set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transition_time_matrix_;
  }
  if (transition_time_matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transition_time_matrix);
    if (message_arena != submessage_arena) {
      transition_time_matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transition_time_matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transition_time_matrix_ = transition_time_matrix;
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Machine.transition_time_matrix)
}

// string name = 16;
inline void Machine::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Machine::name() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Machine.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Machine::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Machine.name)
}
inline std::string* Machine::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Machine.name)
  return _s;
}
inline const std::string& Machine::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Machine::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Machine::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Machine::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Machine.name)
  return _impl_.name_.Release();
}
inline void Machine::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Machine.name)
}

// -------------------------------------------------------------------

// JobPrecedence

// int32 first_job_index = 1;
inline void JobPrecedence::clear_first_job_index() {
  _impl_.first_job_index_ = 0;
}
inline int32_t JobPrecedence::_internal_first_job_index() const {
  return _impl_.first_job_index_;
}
inline int32_t JobPrecedence::first_job_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.first_job_index)
  return _internal_first_job_index();
}
inline void JobPrecedence::_internal_set_first_job_index(int32_t value) {
  
  _impl_.first_job_index_ = value;
}
inline void JobPrecedence::set_first_job_index(int32_t value) {
  _internal_set_first_job_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.first_job_index)
}

// int32 second_job_index = 2;
inline void JobPrecedence::clear_second_job_index() {
  _impl_.second_job_index_ = 0;
}
inline int32_t JobPrecedence::_internal_second_job_index() const {
  return _impl_.second_job_index_;
}
inline int32_t JobPrecedence::second_job_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.second_job_index)
  return _internal_second_job_index();
}
inline void JobPrecedence::_internal_set_second_job_index(int32_t value) {
  
  _impl_.second_job_index_ = value;
}
inline void JobPrecedence::set_second_job_index(int32_t value) {
  _internal_set_second_job_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.second_job_index)
}

// int64 min_delay = 3;
inline void JobPrecedence::clear_min_delay() {
  _impl_.min_delay_ = int64_t{0};
}
inline int64_t JobPrecedence::_internal_min_delay() const {
  return _impl_.min_delay_;
}
inline int64_t JobPrecedence::min_delay() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.min_delay)
  return _internal_min_delay();
}
inline void JobPrecedence::_internal_set_min_delay(int64_t value) {
  
  _impl_.min_delay_ = value;
}
inline void JobPrecedence::set_min_delay(int64_t value) {
  _internal_set_min_delay(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.min_delay)
}

// -------------------------------------------------------------------

// JsspInputProblem

// repeated .operations_research.scheduling.jssp.Job jobs = 1;
inline int JsspInputProblem::_internal_jobs_size() const {
  return _impl_.jobs_.size();
}
inline int JsspInputProblem::jobs_size() const {
  return _internal_jobs_size();
}
inline void JsspInputProblem::clear_jobs() {
  _impl_.jobs_.Clear();
}
inline ::operations_research::scheduling::jssp::Job* JsspInputProblem::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _impl_.jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >*
JsspInputProblem::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return &_impl_.jobs_;
}
inline const ::operations_research::scheduling::jssp::Job& JsspInputProblem::_internal_jobs(int index) const {
  return _impl_.jobs_.Get(index);
}
inline const ::operations_research::scheduling::jssp::Job& JsspInputProblem::jobs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _internal_jobs(index);
}
inline ::operations_research::scheduling::jssp::Job* JsspInputProblem::_internal_add_jobs() {
  return _impl_.jobs_.Add();
}
inline ::operations_research::scheduling::jssp::Job* JsspInputProblem::add_jobs() {
  ::operations_research::scheduling::jssp::Job* _add = _internal_add_jobs();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >&
JsspInputProblem::jobs() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _impl_.jobs_;
}

// repeated .operations_research.scheduling.jssp.Machine machines = 2;
inline int JsspInputProblem::_internal_machines_size() const {
  return _impl_.machines_.size();
}
inline int JsspInputProblem::machines_size() const {
  return _internal_machines_size();
}
inline void JsspInputProblem::clear_machines() {
  _impl_.machines_.Clear();
}
inline ::operations_research::scheduling::jssp::Machine* JsspInputProblem::mutable_machines(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _impl_.machines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >*
JsspInputProblem::mutable_machines() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return &_impl_.machines_;
}
inline const ::operations_research::scheduling::jssp::Machine& JsspInputProblem::_internal_machines(int index) const {
  return _impl_.machines_.Get(index);
}
inline const ::operations_research::scheduling::jssp::Machine& JsspInputProblem::machines(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _internal_machines(index);
}
inline ::operations_research::scheduling::jssp::Machine* JsspInputProblem::_internal_add_machines() {
  return _impl_.machines_.Add();
}
inline ::operations_research::scheduling::jssp::Machine* JsspInputProblem::add_machines() {
  ::operations_research::scheduling::jssp::Machine* _add = _internal_add_machines();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >&
JsspInputProblem::machines() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _impl_.machines_;
}

// repeated .operations_research.scheduling.jssp.JobPrecedence precedences = 3;
inline int JsspInputProblem::_internal_precedences_size() const {
  return _impl_.precedences_.size();
}
inline int JsspInputProblem::precedences_size() const {
  return _internal_precedences_size();
}
inline void JsspInputProblem::clear_precedences() {
  _impl_.precedences_.Clear();
}
inline ::operations_research::scheduling::jssp::JobPrecedence* JsspInputProblem::mutable_precedences(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _impl_.precedences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >*
JsspInputProblem::mutable_precedences() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return &_impl_.precedences_;
}
inline const ::operations_research::scheduling::jssp::JobPrecedence& JsspInputProblem::_internal_precedences(int index) const {
  return _impl_.precedences_.Get(index);
}
inline const ::operations_research::scheduling::jssp::JobPrecedence& JsspInputProblem::precedences(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _internal_precedences(index);
}
inline ::operations_research::scheduling::jssp::JobPrecedence* JsspInputProblem::_internal_add_precedences() {
  return _impl_.precedences_.Add();
}
inline ::operations_research::scheduling::jssp::JobPrecedence* JsspInputProblem::add_precedences() {
  ::operations_research::scheduling::jssp::JobPrecedence* _add = _internal_add_precedences();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >&
JsspInputProblem::precedences() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _impl_.precedences_;
}

// int64 makespan_cost_per_time_unit = 4;
inline void JsspInputProblem::clear_makespan_cost_per_time_unit() {
  _impl_.makespan_cost_per_time_unit_ = int64_t{0};
}
inline int64_t JsspInputProblem::_internal_makespan_cost_per_time_unit() const {
  return _impl_.makespan_cost_per_time_unit_;
}
inline int64_t JsspInputProblem::makespan_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.makespan_cost_per_time_unit)
  return _internal_makespan_cost_per_time_unit();
}
inline void JsspInputProblem::_internal_set_makespan_cost_per_time_unit(int64_t value) {
  
  _impl_.makespan_cost_per_time_unit_ = value;
}
inline void JsspInputProblem::set_makespan_cost_per_time_unit(int64_t value) {
  _internal_set_makespan_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.makespan_cost_per_time_unit)
}

// .google.protobuf.DoubleValue scaling_factor = 5;
inline bool JsspInputProblem::_internal_has_scaling_factor() const {
  return this != internal_default_instance() && _impl_.scaling_factor_ != nullptr;
}
inline bool JsspInputProblem::has_scaling_factor() const {
  return _internal_has_scaling_factor();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JsspInputProblem::_internal_scaling_factor() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.scaling_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& JsspInputProblem::scaling_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
  return _internal_scaling_factor();
}
inline void JsspInputProblem::unsafe_arena_set_allocated_scaling_factor(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* scaling_factor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scaling_factor_);
  }
  _impl_.scaling_factor_ = scaling_factor;
  if (scaling_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JsspInputProblem::release_scaling_factor() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.scaling_factor_;
  _impl_.scaling_factor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JsspInputProblem::unsafe_arena_release_scaling_factor() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.scaling_factor_;
  _impl_.scaling_factor_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JsspInputProblem::_internal_mutable_scaling_factor() {
  
  if (_impl_.scaling_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.scaling_factor_ = p;
  }
  return _impl_.scaling_factor_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* JsspInputProblem::mutable_scaling_factor() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_scaling_factor();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
  return _msg;
}
inline void JsspInputProblem::set_allocated_scaling_factor(::PROTOBUF_NAMESPACE_ID::DoubleValue* scaling_factor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scaling_factor_);
  }
  if (scaling_factor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scaling_factor));
    if (message_arena != submessage_arena) {
      scaling_factor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scaling_factor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scaling_factor_ = scaling_factor;
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
}

// int32 seed = 24;
inline void JsspInputProblem::clear_seed() {
  _impl_.seed_ = 0;
}
inline int32_t JsspInputProblem::_internal_seed() const {
  return _impl_.seed_;
}
inline int32_t JsspInputProblem::seed() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.seed)
  return _internal_seed();
}
inline void JsspInputProblem::_internal_set_seed(int32_t value) {
  
  _impl_.seed_ = value;
}
inline void JsspInputProblem::set_seed(int32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.seed)
}

// string name = 16;
inline void JsspInputProblem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& JsspInputProblem::name() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JsspInputProblem::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.name)
}
inline std::string* JsspInputProblem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _s;
}
inline const std::string& JsspInputProblem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void JsspInputProblem::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* JsspInputProblem::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* JsspInputProblem::release_name() {
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _impl_.name_.Release();
}
inline void JsspInputProblem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.name)
}

// -------------------------------------------------------------------

// AssignedTask

// int32 alternative_index = 1;
inline void AssignedTask::clear_alternative_index() {
  _impl_.alternative_index_ = 0;
}
inline int32_t AssignedTask::_internal_alternative_index() const {
  return _impl_.alternative_index_;
}
inline int32_t AssignedTask::alternative_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedTask.alternative_index)
  return _internal_alternative_index();
}
inline void AssignedTask::_internal_set_alternative_index(int32_t value) {
  
  _impl_.alternative_index_ = value;
}
inline void AssignedTask::set_alternative_index(int32_t value) {
  _internal_set_alternative_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedTask.alternative_index)
}

// int64 start_time = 2;
inline void AssignedTask::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t AssignedTask::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t AssignedTask::start_time() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedTask.start_time)
  return _internal_start_time();
}
inline void AssignedTask::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void AssignedTask::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedTask.start_time)
}

// -------------------------------------------------------------------

// AssignedJob

// repeated .operations_research.scheduling.jssp.AssignedTask tasks = 1;
inline int AssignedJob::_internal_tasks_size() const {
  return _impl_.tasks_.size();
}
inline int AssignedJob::tasks_size() const {
  return _internal_tasks_size();
}
inline void AssignedJob::clear_tasks() {
  _impl_.tasks_.Clear();
}
inline ::operations_research::scheduling::jssp::AssignedTask* AssignedJob::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _impl_.tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >*
AssignedJob::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.AssignedJob.tasks)
  return &_impl_.tasks_;
}
inline const ::operations_research::scheduling::jssp::AssignedTask& AssignedJob::_internal_tasks(int index) const {
  return _impl_.tasks_.Get(index);
}
inline const ::operations_research::scheduling::jssp::AssignedTask& AssignedJob::tasks(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _internal_tasks(index);
}
inline ::operations_research::scheduling::jssp::AssignedTask* AssignedJob::_internal_add_tasks() {
  return _impl_.tasks_.Add();
}
inline ::operations_research::scheduling::jssp::AssignedTask* AssignedJob::add_tasks() {
  ::operations_research::scheduling::jssp::AssignedTask* _add = _internal_add_tasks();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >&
AssignedJob::tasks() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _impl_.tasks_;
}

// int64 due_date_cost = 2;
inline void AssignedJob::clear_due_date_cost() {
  _impl_.due_date_cost_ = int64_t{0};
}
inline int64_t AssignedJob::_internal_due_date_cost() const {
  return _impl_.due_date_cost_;
}
inline int64_t AssignedJob::due_date_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.due_date_cost)
  return _internal_due_date_cost();
}
inline void AssignedJob::_internal_set_due_date_cost(int64_t value) {
  
  _impl_.due_date_cost_ = value;
}
inline void AssignedJob::set_due_date_cost(int64_t value) {
  _internal_set_due_date_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedJob.due_date_cost)
}

// int64 sum_of_task_costs = 3;
inline void AssignedJob::clear_sum_of_task_costs() {
  _impl_.sum_of_task_costs_ = int64_t{0};
}
inline int64_t AssignedJob::_internal_sum_of_task_costs() const {
  return _impl_.sum_of_task_costs_;
}
inline int64_t AssignedJob::sum_of_task_costs() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.sum_of_task_costs)
  return _internal_sum_of_task_costs();
}
inline void AssignedJob::_internal_set_sum_of_task_costs(int64_t value) {
  
  _impl_.sum_of_task_costs_ = value;
}
inline void AssignedJob::set_sum_of_task_costs(int64_t value) {
  _internal_set_sum_of_task_costs(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedJob.sum_of_task_costs)
}

// -------------------------------------------------------------------

// JsspOutputSolution

// repeated .operations_research.scheduling.jssp.AssignedJob jobs = 1;
inline int JsspOutputSolution::_internal_jobs_size() const {
  return _impl_.jobs_.size();
}
inline int JsspOutputSolution::jobs_size() const {
  return _internal_jobs_size();
}
inline void JsspOutputSolution::clear_jobs() {
  _impl_.jobs_.Clear();
}
inline ::operations_research::scheduling::jssp::AssignedJob* JsspOutputSolution::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _impl_.jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >*
JsspOutputSolution::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return &_impl_.jobs_;
}
inline const ::operations_research::scheduling::jssp::AssignedJob& JsspOutputSolution::_internal_jobs(int index) const {
  return _impl_.jobs_.Get(index);
}
inline const ::operations_research::scheduling::jssp::AssignedJob& JsspOutputSolution::jobs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _internal_jobs(index);
}
inline ::operations_research::scheduling::jssp::AssignedJob* JsspOutputSolution::_internal_add_jobs() {
  return _impl_.jobs_.Add();
}
inline ::operations_research::scheduling::jssp::AssignedJob* JsspOutputSolution::add_jobs() {
  ::operations_research::scheduling::jssp::AssignedJob* _add = _internal_add_jobs();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >&
JsspOutputSolution::jobs() const {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _impl_.jobs_;
}

// int64 makespan_cost = 2;
inline void JsspOutputSolution::clear_makespan_cost() {
  _impl_.makespan_cost_ = int64_t{0};
}
inline int64_t JsspOutputSolution::_internal_makespan_cost() const {
  return _impl_.makespan_cost_;
}
inline int64_t JsspOutputSolution::makespan_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.makespan_cost)
  return _internal_makespan_cost();
}
inline void JsspOutputSolution::_internal_set_makespan_cost(int64_t value) {
  
  _impl_.makespan_cost_ = value;
}
inline void JsspOutputSolution::set_makespan_cost(int64_t value) {
  _internal_set_makespan_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspOutputSolution.makespan_cost)
}

// int64 total_cost = 3;
inline void JsspOutputSolution::clear_total_cost() {
  _impl_.total_cost_ = int64_t{0};
}
inline int64_t JsspOutputSolution::_internal_total_cost() const {
  return _impl_.total_cost_;
}
inline int64_t JsspOutputSolution::total_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.total_cost)
  return _internal_total_cost();
}
inline void JsspOutputSolution::_internal_set_total_cost(int64_t value) {
  
  _impl_.total_cost_ = value;
}
inline void JsspOutputSolution::set_total_cost(int64_t value) {
  _internal_set_total_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspOutputSolution.total_cost)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace jssp
}  // namespace scheduling
}  // namespace operations_research

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto
